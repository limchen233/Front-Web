<img src="https://github.com/limchen233/picgo/blob/master/img/image-20201216163137583.png?raw=true" style="zoom: 33%;" /><img src="https://github.com/limchen233/picgo/blob/master/img/image-20201216162331170.png?raw=true" style="zoom: 33%;" /><img src="https://github.com/limchen233/picgo/blob/master/img/image-20201216163554503.png?raw=true" style="zoom: 33%;" /><img src="https://github.com/limchen233/picgo/blob/master/img/image-20201216163823081.png?raw=true" style="zoom:33%;" /> 



首页日常任务模块--->日常任务列表（父组件）-->任务列表（子组件）-->详情页（孙组件）

需求如图，就是从首页进入功能列表页父组件，滚动一段距离点击`自立项目`进入到任务子组件，再滚动一段距离点击`第一条带日期的那一项`进入任务详情，然后返回时要返回到刚才滚动的位置，而不是从列表第一条开始。

项目使用的`vue`框架和`vant`组件，我按照`vue`官方文档里介绍说把`<router-view>`用`<keep-alive>`包裹起来就可以实现，各组件内也定义了`name`属性，然而并没有卵用，每次返回都是从第一条显示。网上搜了下大概有两个原因：

1、`<router-view>`嵌套在层级不同的`<router-view>`中切换会出现缓存数据失效。

2、`<keep-alive>`只对直属的子组件有效，**多个共用组件导致的`<keep-alive>`缓存失效**。

解决方法：

1、既然是多个`router-view`嵌套并且共用的情况下造成的，那么如果只存在一个`router-view`，也就是只需要`app.vue`作为框架内所有页面的容器，就不会有这个问题。然后将`router`转换一下，全部转换成一级路由。

2、不转换路由层级，使用`scrollIntoView()`或者获取父组件的`scrollTop`。

> `Element`接口的`scrollIntoView()`方法会滚动元素的父容器，使被调用`scrollIntoView()`的元素对用户可见。[具体请参考](https://developer.mozilla.org/zh-CN/docs/Web/API/Element/scrollIntoView)
>
> `Element.scrollTop` 属性可以获取或设置一个元素的内容垂直滚动的像素数。一个元素的 `scrollTop` 值是这个元素的**内容顶部**（卷起来的）到它的视口可见内容（的顶部）的距离的度量。当一个元素的内容没有产生垂直方向的滚动条，那么它的 `scrollTop` 值为`0`。[scrollTop](https://developer.mozilla.org/zh-CN/docs/Web/API/Element/scrollTop)

我在项目中使用了第二种解决方案，因为我觉得带层级的路由更清晰些。而且有的页面功能类似，采用封装好的通用组件可以减少大量代码。（在一级路由中引用封装的组件也可能造成缓存失败）

因为`scrollIntoView()`只能设置滚动位置为`start/center/end/nearest`，滚动位置并不精确，体验不是太好，而且兼容性没有`scrollTop`好，所以选择了 `Element.scrollTop` 。



