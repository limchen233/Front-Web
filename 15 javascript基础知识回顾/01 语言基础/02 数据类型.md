`ECMAScript`有6种简单数据类型（也称为原始类型）：
`Undefined` 、 `Null` 、 `Boolean` 、 `Number` 、 `String` 和`Symbol` 。 `Symbol` （符号）是`ECMAScript 6`新增的。还有一种复杂数据类型叫 `Object`（对象）。 `Object` 是一种无序名值对的集合。

#### `typeof` 操作符

因为`ECMAScript`的类型系统是松散的，所以需要一种手段来确定任意变量的数据类型。 `typeof` 操作符就是为此而生的。对一个值使用 `typeof` 操作符会返回?列字符串之一：

- "undefined" 表示值未定义；

- "boolean" 表示值为布尔值；

- "string" 表示值为字符串；

- "number" 表示值为数值；

- "object" 表示值为对象（而不是函数）或 null ；

- "function" 表示值为函数；

- "symbol" 表示值为符号

	```javascript
	let message = "some string";
	console.log(typeof message); // "string"
	console.log(typeof(message)); // "string"
	console.log(typeof 95); // "number"
	```

	在这个例子中，我们把一个变量（ message ）和一个数值字面量传给了 `typeof` 操作符。注意，因为 `typeof` 是一个操作符而不是函数，所以不需要参数（但可以使用参数）。

	> 注意：
	>
	> 1、`typeof` 在某些情况下返回的结果可能会让人费解，但技术上讲还是正确的。比如，调用 `typeof null` 返回的是 "object" 。这是因为特殊值 null 被认为是一个对空对象的引用。
	>
	> 2、严格来讲，函数在`ECMAScript`中被认为是对象，并不代表一种数据类型。可是，函数也有自己特殊的属性。为此，就有必要通过 `typeof` 操作符来区分函数和其他对象。

#### Undefined类型

Undefined类型只有一个值，就是`undefined`。当声明了变量但没有初始化时，就相当于给变量赋予了`undefined`值。

```javascript
var a;
let b;
console.log(a) // undefined
console.log(b) // undefined
```

> 注意：
>
> 1、一般来说，永远不用显示的给某个变量设置`undefined`值。字面值 `undefined` 主要用于比较，而且在`ECMA-262`第3版之前是不存在的。增加这个特殊值的目的就是为了正式明确空对象指针（ null ）和未初始化变量的区别。
>
> 2、无论是声明还是未声明， `typeof` 返回的都是字符串 "undefined" 。逻辑上讲这是对的，因为虽然严格来讲这两个变量存在根本性差异，但它对任何一个变量都不可能执行什么真正的操作。
>
> ```
> let name;
> console.log(typeof name) // undefined
> console.log(typeof age) // undefined
> ```
>
> 3、建议在声明变量的同时进行初始化。这样，当 `typeof` 返回 "undefined" 时，你就会知道那是因为给定的变量尚未声明，而不是声明了但未初始化。

#### Null类型

null类型也只有一个值 ，即`null`。

`null`值表示一个空对象指针，所以才有`typeof null`返回`object`

```
let a = null
console.log(typeof a) // object
```

在定义将来要保存对象值的变量时，建议使用 null 来初始化，不要使用其他值。这样，只要检查这个变量的值是不是 null 就可以知道这个变量是否在后来被重新赋予了一个对象的引用。

> 注：
>
> 1、undefined 值是由 null 值派生而来，因此`ECMAScript-262`将它们定义为表面相等
>
> ```javascript
> console.log(null == undefined) // true，`==`会将两边的值先转化再比较
> console.log(null === undefined) // false
> ```
>
> 2、即使 null 和 undefined 有关系，它们的用途也是完全不一样的。如前所述，永远不必显式地将变量值设置为 undefined 。但null 不是这样的。任何时候，只要变量要保存对象，而当时又没有那个对象可保存，就要用 null 来填充该变量。这样就可以保持null 是空对象指针的语义，并进一步将其与undefined 区分开来。

#### Boolean类型

`Boolean`(布尔值)类型是`Ecmascript`中使用最频繁的类型之一，有两个字面值：`true`和`false`。

布尔值字面量 `true` 和 `false` 是区分大小写的，因此`True` 和 `False` （及其他大小混写形式）是有效的标识符，但不是布尔值。

虽然布尔值只有两个，但所有其他`ECMAScrip`t类型的值都有相应布尔值的等价形式。要将一个其他类型的值转换为布尔值，可以调用特定的 `Boolean()` 转型函数：

```javascript
let msg = 'hello'
let msgAsBoolean = Boolean(msg)
```

字符串 message 会被转换为布尔值并保存在变量 `msgAsBoolean`中。 `Boolean()` 转型函数可以在任意类型的数据上调用，而且始终返回一个布尔值。

不同类型与布尔值之间的转换关系：（重要）

|  数据类型   |     转换为true的值      | 转换为false的值 |
| :---------: | :---------------------: | :-------------: |
|  `Boolean`  |         `true`          |     `false`     |
|  `String`   |       非空字符串        | `""`(空字符串)  |
|  `Number`   | 非`0`数值（包括无穷值） |  `0` 、 `NaN`   |
|  `Object`   |        任意对象         |     `null`      |
| `Undefined` |     `N/A`（不存在）     |   `undefined`   |

#### Number类型

`Number` 类型使用IEEE 754格式表示整数和浮点值（在某些语言中也叫双精度值）。不同的数值类型相应地也有不同的数值字面量格式。最基本的数值字面量格式是十进制整数，直接写出来即可：

```javascript
let intNum = 20;
```

整数也可以用八进制（以8为基数）或十六进制（以16为基数）字面量表示。对于八进制字面量，第一个数字必须是零（0），然后是相应的八进制数字（数值0~7）。如果字面量中包含的数字超出了应有的范围，就会忽略前缀的零，后面的数字序列会被当成十进制数，如下所示：

```javascript
let octalNum1 = 070; // 八进制的56
let octaNum2 = 079; // 无效的八进制值，当成79处理
let octalNum3 = 08; // 无效的八进制值，当成8处理
```

> 注意：八进制字面量在严格模式下是无效的，会导致JavaScript引擎抛出语法错误。`ECMAScript 2015`或`ES6`中的八进制值通过前缀 `0o` 来表示；严格模式下，前缀 0 会被视为语法错误，如果要表示八进制值，应该使用前缀 `0o` 。

要创建十六进制字面量，必须让真正的数值前缀 `0x` （区分大小写），然后是十六进制数字（0~9以A~F）。十六进制数字中的字母大小写均可。

```javascript
let hexNum1 = 0xA; // 十六进制10
let hexNum2 = 0x1f; // 十六进制31
```

> 注意：
>
> 1、使用八进制和十六进制格式创建的数值在所有数学操作中都被视为十进制数值。
>
> 2、由于JavaScript保存数值的方式，实际中可能存在正零（+0）和负零（-0）。正零和负零在所有情况下都被认为是等同的。

###### 1、浮点值

要定义浮点值，数值中必须包含小数点，而且小数点后面必须至少有一个数字。虽然小数点前面不是必须有整数，但推荐加上。

```javascript
let floatNum1 = 1.1;
let floatNum2 = 0.1;
let floatNum3 = .1; // 有效，但不推荐
```

因为存储浮点值使用的内存空间是存储整数值的两倍， 所以`ECMAScript`总是想方设法把值转换为整数。在小数点后面没有数字的情况?，数值就会变成整数。类似地，如果数值本身就是整数，只是小数点后面跟0（如1.0），那它也会被转换为整数：

```javascript
let floatNum1 = 1.; // 小数点后面没有数字，当成整数1处理
let floatNum2 = 10.0;  // 小数点后面是零，当成整数10处理
```

对于非常大或非常小的数值，浮点值可以用科学记数法来表示。科学记数法用于表示一个应该乘以10的给定次幂的数值。

`ECMAScript`中科学记数法的格式要求是一个数值（整数或浮点数）后跟一个大写或小写的字母e，再加上个要乘的10的多少次幂。比如：

```javascript
let floatNum = 3.125e7;  // 等于31250000
```

在这个例子中， `floatNum` 等于31 250 000，只不过科学记数法显得更简洁。这种表示法实际上相当于说：“以3.125作为系数，乘以10的7次幂。

科学记数法也可以用于表示非常小的数值，例如0.000 000 000 000000 03。这个数值用科学记数法可以表示为`3e-17`。默认情况下，`ECMAScript`会将小数点后至少包含6个零的浮点值转换为科学记数法（例如，0.000 000 3会被转换为`3e-7`）。

浮点值的精确度最高可达17位小数，但在算术计算中远不如整数精确。例如，0.1加0.2得到的不是0.3，而是0.300 000 000 000 00004。由于这种微小的舍入错误，导致很难测试特定的浮点值。

这里检测两个数值之和是否等于0.3。如果两个数值分别是0.05和0.25，或者0.15和0.15，那没问题。但如果是0.1和0.2，如前所述，测试将失败。因此永远不要测试某个特定的浮点值。

> 注意 ：之所以存在这种舍入错误，是因为使用了IEEE 754数值，这种错误并非`ECMAScript`所独有。其他使用相同格式的语言也有这个问题。

###### 2、值的范围

由于内存的限制，`ECMAScript`并不支持所有数值。它表示的最小数值保存在`Number.MIN_VALUE`中，这个值在大多数浏览器中是`5e-324`，最大数值保存在`Number.MAX_VALUE`中，这个值在大多数浏览器中是`1.797 693 134 862 315 7e+308`。如果某个计算得到的数值结果超出了JavaScript可以表示的范围，那么这个数值会被自动转换为一个特殊的 `Infinity` （无穷）值。任何无法表示的负数以 `-Infinity` （负无穷大）表示，任何无法表示的正数以 `Infinity` （正无穷大）表示。

如果计算返回正 Infinity 或负 Infinity ，则该值将不能再进一步用于任何计算。这是因为 Infinity 没有可用于计算的数值表示形式。要确定一个值是不是有限大（即介于JavaScript能表示的最小值和最大值之间），可以使用 `isFinite()` 函数，如下所示：

```javascript
let result = Number.MAX_VALUE +
Number.MAX_VALUE;
console.log(isFinite(result)); // false
```

虽然超出有限数值范围的计算并不多见，但总归还是有可能的。因此在计算非常大或非常小的数值时，有必要监测一下计算结果是否超出范围。

> 注意 使用 `Number.NEGATIVE_INFINITY` 和`Number.POSITIVE_INFINITY` 也可以获取正、负Infinity 。没错，这两个属性包含的值分别就是 -Infinity 和 Infinity 。

###### 3、`NaN`

`NaN`是一个特殊的值，意思是"不是数值"（not a number），用来表示本来要返回数值的操作失败了（而不是抛出错误）。比如，用0除任意数值在其他语言中通常都会导致错误，从而中止代码执行。但`ECMAScript`中，0、+0或-0相除会返回`NaN` ：

```javascript
console.log(0/0); // NaN
console.log(-0/+0); // NaN
```

如果分子是非0值，分母是有符号0或无符号0，则会返回Infinity 或 -Infinity ：

```
console.log(5/0); // Infinity
console.log(5/-0); // -Infinity
```

`NaN`有几个独特的属性：

（1）任何涉及`NaN`的操作，始终返回`NaN`

（2）`NaN`不等于任何值，包括它本身  `console.log(NaN == NaN) // false`

`ECMAScript`提供了 `isNaN()` 函数。该函数接收一个参数，可以是任意数据类型，然后判断这个参数是否“不是数值”。把一个值传给 `isNaN()` 后，该函数会尝试把它转换为数值。某些非数值的值可以直接转换成数值，如字符串 "10" 或布尔值。任何不能转换为数值的值都会导致这个函数返回 true 。

```javascript
console.log(isNaN(NaN)); // true
console.log(isNaN(10)); // false，10是数值
console.log(isNaN("10")); // false，可以转换为数值10
console.log(isNaN("blue")); // true，不可以转换为数值
console.log(isNaN(true)); // false，可以转换为数值1
```

###### 4、数值转换

`Number()、parseInt()、parseFloat()`可以将非数值转换为数值。

`Number()`是转型函数，可用于任何数据类型

`parseInt() 和 parseFloat()`主要用于将字符串转换为数值

`Number()`函数转换规则：

- 布尔值，`true`转换为1，`false`转换为0;
- 数值，直接返回；
- `null`，返回0；
- `undefined`，返回`NaN`。
- 字符串：
	1. 如果字符串包含数值字符，包括数值字符前面带加、减号的情况，则转换为一个十进制数值。因此，Number("1") 返回1， Number("123") 返回123，Number("011") 返回11（忽略前面的零）。
	2. 如果字符串包含有效的浮点值格式如 "1.1" ，则会转换为相应的浮点值（同样，忽略前面的零）。
	3. 如果字符串包含有效的十六进制格式如 `"0xf"` ，则会转换为与该十六进制值对应的十进制整数值。
	4. 如果是空字符串（不包含字符），则返回0。
	5. 如果字符串包含除上述情况之外的其他字符，则返回`NaN` 。
- 对象，调用`valueof()`方法，并按照上述规则转换返回的值。如果转换结果是`NaN`，则调用`toString()`方法，再按照转换字符串的规则转换。

