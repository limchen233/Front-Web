## 什么是浏览器缓存

`浏览器缓存(Brower Caching)`是浏览器在本地磁盘对用户最近请求过的文档进行存储，当访问者再次访问同一页面时，浏览器就可以直接从本地磁盘加载文档。 浏览器缓存的优点有：

1. 减少了冗余的数据传输，节省了带宽
2. 减少了服务器的负担，大大提升了网站的性能
3. 加快了客户端加载网页的速度

在前端开发面试中，浏览器缓存是web性能优化面试题中很重要的一个知识点，从而说明浏览器缓存是提升web性能的一大利器，但是浏览器缓存如果使用不当，也会产生很多问题。所以，结合最近遇到的案例，本文对浏览器缓存相关的知识进行总结归纳。

## 浏览器缓存的分类

浏览器缓存主要有两类：`强缓存`和`协商缓存`。 

浏览器在第一次请求发生后，再次请求时：

1. 浏览器会先获取该资源缓存的header信息，根据其中的`expires`和`cahe-control`判断是否命中`强缓存`，若命中则直接从缓存中获取资源，包括缓存的header信息，本次请求不会与服务器进行通信；
2. 如果没有命中强缓存，浏览器会发送请求到服务器，该请求会携带第一次请求返回的有关缓存的header字段信息（`Last-Modified/IF-Modified-Since、Etag/IF-None-Match`）,由服务器根据请求中的相关header信息来对比结果是否命中协商缓存，若命中，则服务器返回新的响应header信息更新缓存中的对应header信息，但是并不返回资源内容，它会告知浏览器可以直接从缓存获取；否则返回最新的资源内容。

#### 强缓存

强缓存是利用`http`的返回头中的`Expires`或者`Cache-Control`两个字段来控制的，用来表示资源的缓存时间。 

**Expires** 该字段是`http1.0`时的规范，它的值为一个绝对时间的GMT格式的时间字符串，比如`Expires:Mon,18 Oct 2066 23:59:59` GMT。这个时间代表着这个资源的失效时间，在此时间之前，即命中缓存。这种方式有一个明显的缺点，由于失效时间是一个绝对时间，所以当服务器与客户端时间偏差较大时，就会导致缓存混乱。

 **Cache-Control** Cache-Control是`http1.1`时出现的header信息，主要是利用该字段的`max-age`值来进行判断，它是一个相对时间，例如`Cache-Control:max-age=3600`，代表着资源的有效期是3600秒。Cache-control除了该字段外，还有下面几个比较常用的设置值：

- no-cache：不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在`ETag`，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。
- no-store：禁止浏览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。
- public：可以被所有的用户缓存，包括终端用户和`CDN、Nginx`等中间代理服务器。
- private：所有内容只有客户端可以缓存，不允许`CDN、Nginx`等中继缓存服务器对其缓存。**Cache-Control的默认取值**
- `max-age=xxx`：缓存内容将在`xxx`秒后失效

> **注意：Cache-Control与Expires可以在服务端配置同时启用，同时启用的时候Cache-Control优先级高。**

#### 协商缓存

协商缓存就是由**`服务器来确定缓存资源`**是否可用，所以客户端与服务器端要通过某种标识来进行通信，从而让服务器判断请求资源是否可以缓存访问，这主要涉及到下面两组header字段，这两组搭档都是`成对`出现的，即第一次请求的响应头带上某个字段（`Last-Modified`或者`Etag`），则后续请求则会带上对应的请求字段（`If-Modified-Since`或者`If-None-Match`），若响应头没有`Last-Modified`或者`Etag`字段，则请求头也不会有对应的字段。

 **`Last-Modify/If-Modify-Since`** 浏览器第一次请求一个资源的时候，服务器返回的header中会加上`Last-Modify`，`Last-modify`是一个时间标识，返回该资源文件在**服务器**最后被修改的时间，例如`Last-Modify: Thu,31 Dec 2037 23:59:59 GMT`。 当浏览器再次请求该资源时，request的请求头中会包含`If-Modify-Since`，该值为缓存之前返回的`Last-Modify`。服务器收到`If-Modify-Since`后，根据资源的最后修改时间判断是否命中缓存。 如果命中缓存，则返回304，并且不会返回资源内容，并且不会返回`Last-Modify`。

 **`ETag/If-None-Match`** 与**`Last-Modify/If-Modify-Since`**不同的是，**`Etag/If-None-Match`**返回的是一个校验码。`Etag`是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)。`ETag`可以保证每一个资源是唯一的，资源变化都会导致`ETag`变化。服务器根据浏览器请求时的`If-None-Match`值来判断是否命中缓存。 与`Last-Modified`不一样的是，当服务器返回`304 Not Modified`的响应时，由于`ETag`重新生成过，`response header`中还会把这个`ETag`返回，即使这个`ETag`跟之前的没有变化。 

> **强缓存与协商缓存异同：**
>
> - **两者的共同点是：如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据；**
> - **两者的区别是：强缓存不发请求到服务器，协商缓存会发请求到服务器。**



### Last-Modified 与 `ETag`

你可能会觉得使用`Last-Modified`已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要`Etag`呢？`HTTP1.1`中`Etag`的出现主要是为了解决几个`Last-Modified`比较难解决的问题：

- 一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET；
- 某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说`1s`内修改了N次)，`If-Modified-Since`能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录`MTIME`只能精确到秒)；
- 有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形。

`Etag` 是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加准确的控制缓存。`Last-Modified` 与 `ETag` 是可以一起使用的，**服务器会优先验证 `ETag`**，一致的情况下，才会继续比对 `Last-Modified`，最后才决定是否返回 304。

## 如果服务端没有设置 Cache-Control 怎么办 （同时没有Expires）？

浏览器有自己的优化策略。

以`chorme`浏览器为例：

第一次：协商缓存，询问服务端，资源是否改变，已改变则发起请求。没改变的话，304重定向，并根据响应头的date和last-modified计算出强制缓存的时间（类似强制设置 Cache-Control: max-age=xx）。

第二次开始：就有强制缓存了，状态码为200。

