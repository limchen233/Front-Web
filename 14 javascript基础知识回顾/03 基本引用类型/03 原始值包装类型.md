`ECMAScript`提供了3种特殊的引用类型：`Boolean、Number、String`。这些类型具有引用类型一样的特点，但也具有与各自原始类型对应的特殊行为。**每当用到某个原始值的方法或属性时，后台都会创建一个相应原始包装类型的对象，从而暴露出操作原始值的各种方法，操作完又自动销毁。**

例子：

```javascript
let s1 = 'some text'
let s2 = s1.substring(2)
/**
 s1是一个包含字符串的变量，它是一个原始值；
 第二行在s1上调用了substring方法，并把结果保存在s2中；
 我们知道，原始值本身不是对象，因此逻辑上不应该有方法，但是这个例子又确实按照预期运行了。这是因为后台作了处理。
*/
```

后台执行的操作：

- 创建一个`String`类型的实例
- 调用实例上的特定方法
- 销毁实例

```javascript
// 代码实现
let s1 = new String('some text')
let s2 = s1.substring(2)
s1 = null
```

这种行为可以让原始值拥有对象的行为。对布尔值和数值而言，以上3步也会在后台发生，只不过使用的是Boolean和Number包装类型而已。

> 引用类型与原始值包装类型的主要区别在于对象的生命周期。在通过new实例化引用 类型后，得到的实例会在离开作用域时被销毁，而**自动创建的原始值包装对象则只存在于访问它的那行代码期间**。这意味着不能在运行时给原始值添加属性和方法。
>
> **在原始值包装类型的实例上调用`typeof`会返回`object`，所有原始值包装对象都会转换为布尔值true。**



**1、Boolean**

Boolean是对应布尔值的引用类型。要创建一个Boolean对象，就使用Boolean构造函数并传入true或false

```javascript
let booleanObject = new Boolean(true)
```

Boolean的实例会重写`valueOf()`方法，返回一个原始值`true`或`false`。`toString()`方法被调用时也会被覆盖，返回字符串`"true"`或`"false"`。

**2、Number**

Number是对应数值的引用类型。

```javascript
let numberObject = new Number(10)
```

与Boolean类型一样，Number类型重写了`valueOf()、toLocaleString()`和`toString()`方法。`valueOf()`方法返回Number对象表示的原始数值，另外两个方法返回数值字符串。`toString()`方法可选地接收一个表示基数的参数，并返回相应基数形式的数值字符串。

```javascript
let num = 10
console.log(num.toString()) // '10'
console.log(num.toString(2)) // '1010' 二进制
console.log(num.toString(8)) // '12' 八进制
console.log(num.toString(10)) // '10' 十进制
console.log(num.toString(16)) // 'a' 十六进制
```

除了继承的方法，Number类型还提供了几个用于将数值格式化为字符串的方法。

- **`toFixed()`**

	`toFixed()`方法返回包含指定小数点位数的数值字符串

	```javascript
	let num = 10
	console.log(num.toFixed(2)) // '10.00'
	```

	`toFixed()`接收了参数2，表示返回的数值字符串要包含两位小数。

	如果数值本身的小位数超过了参数指定的位数，则四舍五入到最近的小位数

	```javascript
	let num = 10.005
	console.log(num.toFixed(2)) // '10.01'
	```



- **`toExponential()`**

	返回以科学记数法（也称为指数记数法）表示的数值字符串。与`toFixed()`一样，`toExponential()`也接收一个参数，表示结果中小数的位数。

	```javascript
	let num = 10
	console.log(num.toExponential(1)) // '1.0e+1'
	```

	

- **`toPrecision()`**

	`toPrecision()`方法会根据情况返回最合理的输出结果，可能是固定长度，也可能是科学记数法形式。这个方法接收一个参数，表示结果中数字的总位数（不包含指数）。

	```javascript
	let number = 99
	console.log(num.toPrecision(1)) // "1e+2"
	console.log(num.toPrecision(2)) // "99"
	console.log(num.toPrecision(3)) // "99.0"
	```

	本质上，`toPrecision()`方法会根据数值和精度来决定调用`toFixed()`还是`toExponential()`。为了以正确的小数位精确表示数值，这3个方法都会向上或向下舍入。

	

- **`isInteger()`**

	用于辨别一个数值是否保存为整数。

	有时候，小数位的0可能会让人误以为数值是一个浮点值：

	```javascript
	console.log(Number.isInteger(1)) // true
	console.log(Number.isInteger(1.00)) // true
	console.log(Number.isInteger(1.01)) // false
	```

	